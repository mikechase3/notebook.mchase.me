# Processes & Process Management

* From second lecture during grad school. Search my PC for `1.2 Process and Process Management` to see the lecture.
* **Processes** are in execution while **applications** are programs on disks not being executed.

## Great External Resources

* What's virtual memory [computerphile](https://www.youtube.com/watch?v=5lFnKYCZT5o\&pp=ygUfT3BlcmF0aW5nIHN5c3RlbXMgY29tcHV0ZXJwaGlsZQ%3D%3D)
* OS Context Switching [computerphile](https://www.youtube.com/watch?v=DKmBRl8j3Ak)
* Program interrupts [computerphile](https://www.youtube.com/watch?v=54BrU82ANww)

## Process Execution State

### What is a processed composed of?

* _See also: what's in a `.exe` file_ [investigation](https://www.youtube.com/watch?v=-ojciptvVtY)

Processes are an abstraction of several components:

1. **Text/Data** have some text, machine code, and other static info like metadata when the file is loaded.
2. **Heap**: during execution, the processes dynamically creates stuff in memory before calculating results.
3. **Stack**: this is a dynamic part of the address space growing/shrinking. Always last-in-first-out.

Processes see **virtual addresses** when running. Anything requiring memory generated by processes is stored in the **address space**. Operating systems use **page tables** to map virtual addresses to physical ones.

### How do Operating Systems Manage Processes?

* **Program Counters**: count the cycles & tells the OS which lines to pause/interrupt/restore from & to.
* The program counter is maintained in a register on the CPU. There are other **CPU Registers**
* **Stack Pointers** tell us where the top of the stack is containing info about the last item.
* **Process Control Blocks** contain all the information about status/execution.

### What is a process control block (PCB) composed of?

All the above information about the status of information is contained in a PCB block. Together, it consists of the:

1. Process state:
2. Process number:
3. Program counter:
4. Registers (the contents in CPU):
5. Memory limits:
6. List of open files:
7. Priority:
8. Signal Mask:
9. CPU Scheduling Info:

### How do we Use Process Control Blocks?

* We discussed this in a high-level.
* When context switching, the CPU saves the state to a PCB block and restores other.
* When more memory is needed, we perform a **Mallotcall**

### What is Context Switching?

Context switching when you swap between processes. It is **expensive** because it takes lots of cycles to load & store all the values of the PCB to/from mem

## Process Lifecycle

### What is the lifecycle of a process. (List the "states" it goes through")

1. **New:** Initially, a process enters the "new" state where the OS performs admission control & determine whether to block or allow a process to run based on policy & available resources.
2. **Ready**: process is admitted & ready to start executing. It's on-hold for the scheduler to move it to a running state.
3. **Running**: after the **scheduler dispatch**, it'll run and be in (`interrupt` || `I/O or event wait` | )
4. **Terminated**: it'll exit peacefully and return a result.

This is a redundant visual of what I said above but more complicated: Event waits are usually caused by hard drives and i/o devices. ![](<../../.gitbook/assets/image (153).png>)

| Process    | Comment                                                                                                                                                        |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| new        | The process is being created.                                                                                                                                  |
| running    | Instructions are being executed. The CPU scheduler takes a process from the head of the ready queue to execute. Sometimes, there may be multiple ready queues. |
| Waiting    | The process is waiting for another event to occur.                                                                                                             |
| Ready      | The process is waiting to be assigned to a processor                                                                                                           |
| Terminated | The process has finished execution.                                                                                                                            |

### What are the two commonly used mechanisms for creating a process?

* [**FORK**](https://www.youtube.com/watch?v=9seb8hddeK4\&t=0s) copies the parent PCB onto a new PCB and child continues execution at the fork.
* [**EXEC**](https://www.youtube.com/watch?v=mj2VjcOXXs4\&t=0s): will replace the child imap. It loads new a new program starting from the first instruction.
* Here's an optional [video](https://www.youtube.com/watch?v=l64ySYHmMmY) showing off how these work.

#### FORK

Fork works like this:

1. Operating system creates a new process control block for the child.
2. Then, copy the same values from the parent process control into the child process block.
3. At that point, both the parent & the child will continue their execution at the instruction immediately after the fork.
4. After the operating system completes the fork, both processes will start their execution at the exact same point.

#### EXEC

TOdo: 34:00

#### Misc

* Once the inital boot process is done and the OS is loaded, it'll create some initial process.
  * "It can be represented as a tree". That seemed important.
  * Then more procesess spawn as a user logs in & he starts programs.

## Quiz

### First Draft

Here's what I took to office hours:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **On Fork()**: Dr. X agreed my answer makes logical sense, but wasn't what she's looking for.&#x20;
  * Maybe a better answer includes that we can call an EXEC to replace the child's image with a new program?

{% hint style="warning" %}
She said my answers make sense, but the first one isn't what she's looking for. While the first makes sense,&#x20;
{% endhint %}

## Process Scheduling

* **Role of the CPU Scheduler**: it's an OS component managing how processes use CPU resources. It decides which process is dispatched/running. The OS therefore must be able to:
  * **Preempt**: describes how an OS interrupts and save the current context.&#x20;
  * **Schedule:** runs the scheduler to choose the next process
  * **Dispatch**: dispatches process & switches into its context
* **Cpu Resources are Expensive**: so the OS needs to minimize the amount of time it's scheduling.&#x20;

### Calculating Useful CPU Work

* **Time Slice**: the time allocated to a process on the CPU.
* The scheduler deicdes what are appropriate time-slice values and which metrics to use when processing the next time it should run.

Useful CPU work is defined as:

$$
\frac{\texttt{total processing time}}{total time} \implies \frac{2 * T_p}{2 * T_p + 2 * T_{\texttt{sched}}}
$$

### IO Process Scheduling

So far, we know how processes access resources on the hardware platform, but in addition to memory/CPU we have other I/O devices.&#x20;

* I/O devices are slower and normally, the process will remain "waiting" in the queue until the I/O event is complete.
* The I/O device gets complete & notifies the CPU it's done.&#x20;

## Inter-Process Communication

* IPC mechanisms transfer data/info from one address space to another maintaining protection/isolating that OSes enforce.
* **Message Passing IPC**: the OS provides a communication channel like a shared buffer. Processes write/read messages to/from channels. This approach means the OS will manage the channel and provides the same APIs and system calls for writing/sending/receiving data from the channel; however, there is overhead.&#x20;
* **Shared Memory IPC**: it's a faster path of cmmunicating by reading from RAM.&#x20;

## Processes in Memory

![](<../../.gitbook/assets/image (152).png>)

* An operating system executes a variety of programs
  * Batch systems: **jobs**.
  * Timer-shared systems: **user programs** or **tasks**.
* The textbook uses the terms job and process almost interchangeably.
* **Process**: a program in its execution.
  * Current activity, including the _program counter_, processor registers.
    * A program counter is like a line-by-line examination.
    * A pointer to the current line of execution.
    * Processor registers: temporary holding spaces for data. Smallest, but fastest.
  * Stack: contains temporary data.
    * Function parameters, return addresses, local variables.
    * In operating systems, it specifies a region in the hardware.
  * Data Section: contains global regions?

## Process Control Block PCB

![](<../../.gitbook/assets/image (154).png>)

### Process Scheduling

* Process Scheduling
* Job Queues
